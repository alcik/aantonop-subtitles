WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:06.380
[AUDIENCE] I would like to know what you think about hard forks as a way to evolve protocols in blockchains?

00:00:08.080 --> 00:00:12.820
[ANDREAS] What do we think of hard 
forks as a way to evolve protocols?

00:00:13.780 --> 00:00:20.440
So I'm a big fan of automotive crash tests, right?

00:00:21.520 --> 00:00:27.120
I'm a big fan, I think one of the reasons we have safe automobiles is because of automotive crash tests.

00:00:28.440 --> 00:00:32.040
I'm also a big fan of using dummies

00:00:32.040 --> 00:00:37.740
in the automotive crash tests, where I'm not the passenger. [Laughter] Right?

00:00:38.240 --> 00:00:43.480
Now if someone said, "We have a new bus.
Everybody get on. We don't know how

00:00:43.480 --> 00:00:48.400
it works, but we're gonna run a crash test to find out.

00:00:48.800 --> 00:00:51.620
Jump on!" That's how I feel about hard forks.

00:00:51.780 --> 00:00:56.440
I would rather not be in the crash test
when the crash test is happening.

00:00:57.480 --> 00:01:04.340
Hard forks are dangerous. They're difficult,
complex, and have unintended behaviours.

00:01:04.680 --> 00:01:09.400
Hard forks bring together the nexus
of politics, community response...

00:01:10.620 --> 00:01:15.600
...independent economic agents, self-interest,
monetary policy, and technology.

00:01:15.600 --> 00:01:17.580
Any one of those can go wrong.

00:01:18.040 --> 00:01:26.180
In a recent example, we saw a hard fork in Ethereum.
The hard fork, technologically, was perfect.

00:01:26.720 --> 00:01:27.820
Perfect!

00:01:28.380 --> 00:01:34.580
Economically, politically, in terms of the community 
and self-interested actors? Not so perfect.

00:01:35.220 --> 00:01:41.320
10% of the economic activity, community, hash rate, ended up forking off to a separate coin.

00:01:41.320 --> 00:01:45.160
Now there's two systems with 
competing interests and competing designs.

00:01:45.580 --> 00:01:47.920
I would rather not see that in Bitcoin.

00:01:48.640 --> 00:01:56.280
I'm a bit skeptical of [hard forks] being used as the mechanism to rapidly iterate and mature the protocol.

00:01:56.680 --> 00:02:02.849
But that's one of the design trade-offs that's 
different about Ethereum. Its design trade-off is...

00:02:03.480 --> 00:02:09.460
Because of its model, it needs to iterate a lot more to reach the same level of security / maturity as Bitcoin.

00:02:10.220 --> 00:02:16.020
Because it has a larger attack surface, a larger exposure surface, it's going to go through a lot more hard forks.

00:02:16.020 --> 00:02:18.020
Is that a good thing?
Is that a bad thing?

00:02:18.540 --> 00:02:20.460
It depends what you're trying to use it for.

00:02:21.260 --> 00:02:26.300
I don't think it makes for very good 
sound money or a robust platform.

00:02:26.800 --> 00:02:31.260
But that's a trade-off that allows it to actually have
 much more flexible application development.

00:02:32.180 --> 00:02:33.920
I'm interested in that.

00:02:34.400 --> 00:02:38.460
I think that's the choice I would make for Ethereum. 
It's not the choice I would make for Bitcoin.

00:02:39.020 --> 00:02:41.680
Does that help?
A bit of an esoteric topic.

